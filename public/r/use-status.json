{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-status",
  "type": "registry:hook",
  "title": "Use Status",
  "description": "A hook for managing status states and messages",
  "dependencies": [
    "@untools/logger"
  ],
  "registryDependencies": [
    "@aevr/use-persisted-state"
  ],
  "files": [
    {
      "path": "registry/lagos/hooks/use-status.ts",
      "content": "// ./registry/lagos/hooks/use-status/index.ts\nimport { useState, useCallback, useRef, useMemo } from \"react\";\nimport { usePersistedState } from \"@/registry/lagos/hooks/use-persisted-state\";\nimport { logger } from \"@untools/logger\";\n\nexport type StatusState = \"loading\" | \"success\" | \"error\" | \"warning\" | \"idle\";\n\nexport interface StatusItem {\n  name?: string;\n  status?: StatusState;\n  message?: string;\n  key?: string;\n  timestamp?: number;\n}\n\nexport type StatusRecord<K extends string = string> = Record<K, StatusItem>;\n\nexport interface AggregatedStatus {\n  title: string;\n  description: string;\n  type: StatusState;\n  loading: boolean;\n}\n\ninterface UseStatusOptions<K extends string = string> {\n  strategy?: \"local\" | \"global\";\n  namespace?: string;\n  defaultStatuses?: StatusRecord<K>;\n  // New aggregation options\n  aggregation?: {\n    enabled?: boolean;\n    priority?: K[]; // Order of priority for display\n    defaultTitle?: string;\n    defaultDescription?: string;\n  };\n  // Persistence options (only applies to global strategy)\n  persistence?: {\n    enabled?: boolean;\n    storage?: Storage;\n  };\n}\n\n// Global store interface for managing namespaced status data\ninterface GlobalStatusStore {\n  namespaced: Record<string, StatusRecord>;\n}\n\nexport const useStatus = <K extends string = string>(\n  options: UseStatusOptions<K | string> = {}\n) => {\n  const {\n    strategy = \"local\",\n    namespace = \"default\",\n    defaultStatuses = {} as StatusRecord<K>,\n    aggregation = {},\n    persistence = {},\n  } = options;\n\n  const {\n    enabled: aggregationEnabled = false,\n    priority = [],\n    defaultTitle = \"\",\n    defaultDescription = \"\",\n  } = aggregation;\n\n  const {\n    enabled: persistenceEnabled = false,\n    storage = typeof window !== \"undefined\" ? window.localStorage : undefined,\n  } = persistence;\n\n  // Track if we've initialized defaults to avoid re-initializing on re-renders\n  const defaultsInitialized = useRef(false);\n\n  // Create initial state with defaults (add timestamps to default items)\n  const createInitialState = useCallback((): StatusRecord<K> => {\n    const initialState = {} as StatusRecord<K>;\n    Object.entries(defaultStatuses).forEach(([key, item]) => {\n      (initialState as Record<string, StatusItem>)[key] = {\n        ...(item as StatusItem),\n        timestamp: (item as StatusItem).timestamp || Date.now(),\n      };\n    });\n    return initialState;\n  }, [defaultStatuses]);\n\n  // Local state with defaults\n  const [localStatus, setLocalStatus] =\n    useState<StatusRecord<K>>(createInitialState);\n\n  // Global state management using usePersistedState\n  const globalStoreKey = \"status-store\";\n  const globalInitialState: GlobalStatusStore = { namespaced: {} };\n\n  // Always call usePersistedState - it handles existing stores internally\n  const { state: globalStore, setState: setGlobalStore } = usePersistedState(\n    globalInitialState,\n    {\n      storageKey: globalStoreKey,\n      enablePersistence: persistenceEnabled,\n      storage,\n    }\n  );\n\n  // Get current namespace status from global store\n  const globalStatus = useMemo(() => {\n    return globalStore.namespaced[namespace] || {};\n  }, [globalStore.namespaced, namespace]);\n\n  // Initialize namespace if it doesn't exist\n  const initializeNamespace = useCallback(() => {\n    if (!globalStore.namespaced[namespace]) {\n      setGlobalStore((prev) => ({\n        ...prev,\n        namespaced: {\n          ...prev.namespaced,\n          [namespace]: {},\n        },\n      }));\n    }\n  }, [globalStore.namespaced, namespace, setGlobalStore]);\n\n  // Initialize namespace on first use if using global strategy\n  if (strategy === \"global\") {\n    initializeNamespace();\n  }\n\n  // Initialize defaults for global strategy\n  if (\n    strategy === \"global\" &&\n    !defaultsInitialized.current &&\n    Object.keys(defaultStatuses).length > 0\n  ) {\n    const namespacedStatuses = globalStore.namespaced[namespace] || {};\n    const hasDefaults = Object.keys(defaultStatuses).some(\n      (key) => namespacedStatuses[key] !== undefined\n    );\n\n    if (!hasDefaults) {\n      const statusesWithTimestamps = Object.entries(defaultStatuses).reduce(\n        (acc, [key, item]) => {\n          acc[key] = {\n            ...(item as StatusItem),\n            timestamp: (item as StatusItem).timestamp || Date.now(),\n          };\n          return acc;\n        },\n        {} as Record<string, StatusItem>\n      );\n\n      setGlobalStore((prev) => ({\n        ...prev,\n        namespaced: {\n          ...prev.namespaced,\n          [namespace]: {\n            ...namespacedStatuses,\n            ...statusesWithTimestamps,\n          },\n        },\n      }));\n    }\n    defaultsInitialized.current = true;\n  }\n\n  const status = useMemo<StatusRecord<K>>(\n    () =>\n      (strategy === \"global\"\n        ? (globalStatus as StatusRecord<K>)\n        : localStatus) as StatusRecord<K>,\n    [strategy, globalStatus, localStatus]\n  );\n\n  const setStatus = useCallback(\n    (key: K, item: Omit<StatusItem, \"timestamp\">) => {\n      const statusItem: StatusItem = {\n        ...item,\n        timestamp: Date.now(),\n      };\n\n      if (strategy === \"global\") {\n        setGlobalStore((prev) => ({\n          ...prev,\n          namespaced: {\n            ...prev.namespaced,\n            [namespace]: {\n              ...prev.namespaced[namespace],\n              [key]: {\n                ...prev.namespaced[namespace]?.[key as string],\n                ...statusItem,\n              },\n            },\n          },\n        }));\n      } else {\n        setLocalStatus(\n          (prev) =>\n            ({\n              ...prev,\n              [key]: {\n                ...prev[key],\n                ...statusItem,\n              },\n            } as StatusRecord<K>)\n        );\n      }\n    },\n    [strategy, namespace, setGlobalStore]\n  );\n\n  const clearStatus = useCallback(\n    (key?: K) => {\n      if (strategy === \"global\") {\n        setGlobalStore((prev) => {\n          const namespacedData = prev.namespaced[namespace] || {};\n\n          if (key) {\n            const { [key as string]: removedItem, ...rest } = namespacedData;\n            logger.debug(\"clearStatus\", { key, removedItem, rest });\n            return {\n              ...prev,\n              namespaced: {\n                ...prev.namespaced,\n                [namespace]: rest,\n              },\n            };\n          } else {\n            // Reset to defaults instead of empty when clearing all\n            const defaultsWithTimestamps = Object.entries(\n              defaultStatuses\n            ).reduce((acc, [defaultKey, item]) => {\n              acc[defaultKey] = {\n                ...(item as StatusItem),\n                timestamp: (item as StatusItem).timestamp || Date.now(),\n              };\n              return acc;\n            }, {} as Record<string, StatusItem>);\n\n            return {\n              ...prev,\n              namespaced: {\n                ...prev.namespaced,\n                [namespace]: defaultsWithTimestamps,\n              },\n            };\n          }\n        });\n      } else {\n        if (key) {\n          setLocalStatus((prev) => {\n            const { [key]: removedItem, ...rest } = prev;\n            logger.debug(\"clearStatus\", { key, removedItem, rest });\n            return rest as StatusRecord<K>;\n          });\n        } else {\n          setLocalStatus(createInitialState()); // Reset to defaults instead of empty\n        }\n      }\n    },\n    [strategy, namespace, setGlobalStore, defaultStatuses, createInitialState]\n  );\n\n  const isLoading = (keys?: K[]) => {\n    const targetKeys = keys || (Object.keys(status) as K[]);\n    return targetKeys.some((key) => status[key]?.status === \"loading\");\n  };\n\n  const hasError = (keys?: K[]) => {\n    const targetKeys = keys || (Object.keys(status) as K[]);\n    return targetKeys.some((key) => status[key]?.status === \"error\");\n  };\n\n  const allSuccess = (keys?: K[]) => {\n    const targetKeys = keys || (Object.keys(status) as K[]);\n    return (\n      targetKeys.length > 0 &&\n      targetKeys.every((key) => status[key]?.status === \"success\")\n    );\n  };\n\n  // New: Built-in aggregation logic\n  const aggregatedStatus = useMemo((): AggregatedStatus => {\n    if (!aggregationEnabled) {\n      return {\n        title: defaultTitle,\n        description: defaultDescription,\n        type: \"idle\",\n        loading: false,\n      };\n    }\n\n    const statusEntries = Object.entries(status).filter(\n      ([, statusItem]) => statusItem\n    );\n\n    if (statusEntries.length === 0) {\n      return {\n        title: defaultTitle,\n        description: defaultDescription,\n        type: \"idle\",\n        loading: false,\n      };\n    }\n\n    // Sort by priority if provided, otherwise by timestamp (most recent first), then by status importance\n    const sortedStatuses = statusEntries.sort(([keyA], [keyB]) => {\n      if (priority.length > 0) {\n        const indexA = priority.indexOf(keyA as K);\n        const indexB = priority.indexOf(keyB as K);\n        if (indexA !== -1 && indexB !== -1) return indexA - indexB;\n        if (indexA !== -1) return -1;\n        if (indexB !== -1) return 1;\n      }\n\n      // Use timestamp as primary sort (most recent first)\n      const timestampA = status[keyA as K]?.timestamp || 0;\n      const timestampB = status[keyB as K]?.timestamp || 0;\n      if (timestampA !== timestampB) {\n        return timestampB - timestampA; // Most recent first\n      }\n\n      // Fallback to status priority: loading > error > warning > success > idle\n      const statusPriority = {\n        loading: 0,\n        error: 1,\n        warning: 2,\n        success: 3,\n        idle: 4,\n      };\n      const priorityA = statusPriority[status[keyA as K]?.status || \"idle\"];\n      const priorityB = statusPriority[status[keyB as K]?.status || \"idle\"];\n      return priorityA - priorityB;\n    });\n\n    const [, primaryStatus] = sortedStatuses[0];\n    const hasLoadingStatus = statusEntries.some(\n      ([, statusItem]) => (statusItem as StatusItem)?.status === \"loading\"\n    );\n\n    return {\n      title: (primaryStatus as StatusItem)?.name || defaultTitle,\n      description: (primaryStatus as StatusItem)?.message || defaultDescription,\n      type: (primaryStatus as StatusItem)?.status || \"idle\",\n      loading: hasLoadingStatus,\n    };\n  }, [status, aggregationEnabled, priority, defaultTitle, defaultDescription]);\n\n  return {\n    status,\n    setStatus,\n    clearStatus,\n    isLoading,\n    hasError,\n    allSuccess,\n    // New: Include aggregated status when enabled\n    ...(aggregationEnabled && { aggregatedStatus }),\n  };\n};\n\n// Legacy aggregator hook for backward compatibility\nexport const useStatusAggregator = (\n  statuses: Record<string, StatusItem | undefined>,\n  config: {\n    priority?: string[];\n    defaultTitle?: string;\n    defaultDescription?: string;\n  } = {}\n): AggregatedStatus => {\n  const { priority = [], defaultTitle = \"\", defaultDescription = \"\" } = config;\n\n  return useMemo(() => {\n    const statusEntries = Object.entries(statuses).filter(\n      ([, status]) => status\n    );\n\n    if (statusEntries.length === 0) {\n      return {\n        title: defaultTitle,\n        description: defaultDescription,\n        type: \"idle\",\n        loading: false,\n      };\n    }\n\n    // Sort by priority if provided, otherwise by timestamp (most recent first), then by status importance\n    const sortedStatuses = statusEntries.sort(([keyA], [keyB]) => {\n      if (priority.length > 0) {\n        const indexA = priority.indexOf(keyA);\n        const indexB = priority.indexOf(keyB);\n        if (indexA !== -1 && indexB !== -1) return indexA - indexB;\n        if (indexA !== -1) return -1;\n        if (indexB !== -1) return 1;\n      }\n\n      // Use timestamp as primary sort (most recent first)\n      const timestampA = statuses[keyA]?.timestamp || 0;\n      const timestampB = statuses[keyB]?.timestamp || 0;\n      if (timestampA !== timestampB) {\n        return timestampB - timestampA; // Most recent first\n      }\n\n      // Fallback to status priority: loading > error > warning > success > idle\n      const statusPriority = {\n        loading: 0,\n        error: 1,\n        warning: 2,\n        success: 3,\n        idle: 4,\n      };\n      const priorityA = statusPriority[statuses[keyA]?.status || \"idle\"];\n      const priorityB = statusPriority[statuses[keyB]?.status || \"idle\"];\n      return priorityA - priorityB;\n    });\n\n    const [, primaryStatus] = sortedStatuses[0];\n    const hasLoading = statusEntries.some(\n      ([, status]) => status?.status === \"loading\"\n    );\n\n    return {\n      title: primaryStatus?.name || defaultTitle,\n      description: primaryStatus?.message || defaultDescription,\n      type: primaryStatus?.status || \"idle\",\n      loading: hasLoading,\n    };\n  }, [statuses, priority, defaultTitle, defaultDescription]);\n};\n",
      "type": "registry:hook",
      "target": "hooks/aevr/use-status.ts"
    }
  ]
}