{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "http-client",
  "type": "registry:lib",
  "title": "HTTP Client",
  "description": "A generic, reusable HTTP client with simplified header management, multiple configuration patterns, lifecycle hooks, and flexible response handling.",
  "files": [
    {
      "path": "registry/utils/http-client.ts",
      "content": "// httpClient.ts\n\n/**\n * Generic HTTP Client\n * A flexible, lightweight HTTP client built on fetch API\n * Supports custom headers, retries, timeouts, and both structured/raw responses\n */\n\nexport interface ApiResponse<T = unknown> {\n  success: boolean;\n  data: T;\n  message: string;\n  meta?: Record<string, unknown>;\n}\n\nexport type HttpResponse<T = unknown> = ApiResponse<T> | T;\n\nexport interface HttpClientConfig {\n  baseUrl?: string;\n  headers?: Record<string, string>;\n  timeout?: number;\n  defaultResponseFormat?: \"structured\" | \"raw\" | \"auto\";\n  retries?: number;\n  retryDelay?: number;\n  retryOnStatus?: number[];\n  onRequest?: (url: string, options: RequestInit) => void | Promise<void>;\n  onResponse?: (response: Response) => void | Promise<void>;\n  onError?: (error: ApiError) => void | Promise<void>;\n}\n\nexport class ApiError extends Error {\n  public statusCode?: number;\n  public code?: string;\n  public details?: unknown;\n\n  constructor(\n    message: string,\n    statusCode?: number,\n    code?: string,\n    details?: unknown\n  ) {\n    super(message);\n    this.name = \"ApiError\";\n    this.statusCode = statusCode;\n    this.code = code;\n    this.details = details;\n  }\n}\n\n// Type guard to check if response is in ApiResponse format\nexport function isApiResponse<T>(\n  response: unknown\n): response is ApiResponse<T> {\n  return (\n    typeof response === \"object\" &&\n    response !== null &&\n    \"success\" in response &&\n    \"data\" in response &&\n    \"message\" in response &&\n    typeof response.success === \"boolean\" &&\n    typeof response.message === \"string\"\n  );\n}\n\n// Type guard to check if response is a structured error\nexport function isStructuredError(data: unknown): boolean {\n  return (\n    typeof data === \"object\" &&\n    data !== null &&\n    \"success\" in data &&\n    data.success === false &&\n    \"message\" in data\n  );\n}\n\nexport class HttpClient {\n  private baseUrl: string;\n  private headers: Record<string, string>;\n  private timeout: number;\n  private defaultResponseFormat: \"structured\" | \"raw\" | \"auto\";\n  private retries: number;\n  private retryDelay: number;\n  private retryOnStatus: number[];\n  private onRequest?: (\n    url: string,\n    options: RequestInit\n  ) => void | Promise<void>;\n  private onResponse?: (response: Response) => void | Promise<void>;\n  private onError?: (error: ApiError) => void | Promise<void>;\n\n  constructor(config: HttpClientConfig = {}) {\n    this.baseUrl = (config.baseUrl || \"\").replace(/\\/$/, \"\");\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n      ...config.headers,\n    };\n    this.timeout = config.timeout || 30000; // 30 seconds default\n    this.defaultResponseFormat = config.defaultResponseFormat || \"auto\";\n    this.retries = config.retries || 0;\n    this.retryDelay = config.retryDelay || 1000;\n    this.retryOnStatus = config.retryOnStatus || [408, 429, 500, 502, 503, 504];\n    this.onRequest = config.onRequest;\n    this.onResponse = config.onResponse;\n    this.onError = config.onError;\n  }\n\n  /**\n   * Set a header value\n   */\n  setHeader(key: string, value: string): void {\n    this.headers[key] = value;\n  }\n\n  /**\n   * Remove a header\n   */\n  removeHeader(key: string): void {\n    delete this.headers[key];\n  }\n\n  /**\n   * Set multiple headers at once\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.headers = { ...this.headers, ...headers };\n  }\n\n  /**\n   * Get all current headers\n   */\n  getHeaders(): Record<string, string> {\n    return { ...this.headers };\n  }\n\n  /**\n   * Clear all headers except Content-Type\n   */\n  clearHeaders(): void {\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n    };\n  }\n\n  private async executeWithRetries<T>(\n    requestFn: () => Promise<T>,\n    attempt: number = 1\n  ): Promise<T> {\n    try {\n      return await requestFn();\n    } catch (error) {\n      if (attempt <= this.retries && this.shouldRetry(error)) {\n        await this.delay(this.retryDelay * attempt);\n        return this.executeWithRetries(requestFn, attempt + 1);\n      }\n      throw error;\n    }\n  }\n\n  private shouldRetry(error: unknown): boolean {\n    if (error instanceof ApiError) {\n      return (\n        error.code === \"NETWORK_ERROR\" ||\n        error.code === \"TIMEOUT\" ||\n        (error.statusCode !== undefined &&\n          this.retryOnStatus.includes(error.statusCode))\n      );\n    }\n    return false;\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Main HTTP request method\n   */\n  async request<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    responseFormat: \"structured\" | \"raw\" | \"auto\" = this.defaultResponseFormat\n  ): Promise<HttpResponse<T>> {\n    return this.executeWithRetries(async () => {\n      const url = endpoint.startsWith(\"http\")\n        ? endpoint\n        : `${this.baseUrl}${endpoint}`;\n\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n      const requestOptions: RequestInit = {\n        ...options,\n        headers: {\n          ...this.headers,\n          ...options.headers,\n        },\n        signal: controller.signal,\n      };\n\n      try {\n        // Call onRequest hook if provided\n        if (this.onRequest) {\n          await this.onRequest(url, requestOptions);\n        }\n\n        const response = await fetch(url, requestOptions);\n\n        clearTimeout(timeoutId);\n\n        // Call onResponse hook if provided\n        if (this.onResponse) {\n          await this.onResponse(response);\n        }\n\n        const data: unknown = await response.json();\n\n        if (!response.ok) {\n          const error = this.parseError(\n            data,\n            response.status,\n            response.statusText\n          );\n\n          // Call onError hook if provided\n          if (this.onError) {\n            await this.onError(error);\n          }\n\n          throw error;\n        }\n\n        // Return response based on format preference\n        if (responseFormat === \"raw\" && isApiResponse<T>(data)) {\n          return data.data;\n        } else if (responseFormat === \"structured\" && !isApiResponse<T>(data)) {\n          return {\n            success: true,\n            data: data as T,\n            message: \"Success\",\n            meta: {},\n          };\n        }\n\n        return data as HttpResponse<T>;\n      } catch (error) {\n        clearTimeout(timeoutId);\n\n        if (error instanceof ApiError) {\n          throw error;\n        }\n\n        if (\n          typeof error === \"object\" &&\n          error !== null &&\n          \"name\" in error &&\n          error.name === \"AbortError\"\n        ) {\n          const timeoutError = new ApiError(\"Request timeout\", 408, \"TIMEOUT\");\n          if (this.onError) {\n            await this.onError(timeoutError);\n          }\n          throw timeoutError;\n        }\n\n        const networkError = new ApiError(\n          typeof error === \"object\" &&\n          error !== null &&\n          \"message\" in error &&\n          typeof error.message === \"string\"\n            ? error.message\n            : \"Network error occurred\",\n          0,\n          \"NETWORK_ERROR\",\n          error\n        );\n\n        if (this.onError) {\n          await this.onError(networkError);\n        }\n\n        throw networkError;\n      }\n    });\n  }\n\n  private parseError(\n    data: unknown,\n    status: number,\n    statusText: string\n  ): ApiError {\n    let errorMessage = `HTTP ${status}: ${statusText}`;\n    let errorCode: string | undefined = undefined;\n    let errorDetails: unknown = data;\n\n    if (isStructuredError(data)) {\n      const structuredData = data as {\n        message?: string;\n        meta?: { code?: string; errorCode?: string; [key: string]: unknown };\n        data?: unknown;\n      };\n\n      errorMessage = structuredData.message || errorMessage;\n      errorCode = structuredData.meta?.code || structuredData.meta?.errorCode;\n      errorDetails = structuredData.data || structuredData.meta || data;\n    } else if (typeof data === \"object\" && data !== null && \"error\" in data) {\n      const errorData = data as {\n        error: {\n          message?: string;\n          code?: string;\n          details?: {\n            errors?: string[];\n            [key: string]: unknown;\n          };\n        };\n      };\n\n      if (\n        errorData.error.message &&\n        typeof errorData.error.message === \"string\"\n      ) {\n        errorMessage = errorData.error.message;\n      }\n\n      if (errorData.error.code) {\n        errorCode = errorData.error.code;\n      }\n\n      if (\n        errorData.error.details?.errors &&\n        Array.isArray(errorData.error.details.errors)\n      ) {\n        const validationErrors = errorData.error.details.errors.join(\". \");\n        errorMessage = `${errorMessage}: ${validationErrors}`;\n      }\n\n      errorDetails = errorData.error.details || data;\n    } else if (typeof data === \"string\") {\n      errorMessage = data;\n    }\n\n    return new ApiError(errorMessage, status, errorCode, errorDetails);\n  }\n\n  /**\n   * Convenience method for structured responses\n   */\n  async requestStructured<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<ApiResponse<T>> {\n    const response = await this.request<T>(endpoint, options, \"auto\");\n\n    if (isApiResponse<T>(response)) {\n      return response;\n    }\n\n    return {\n      success: true,\n      data: response as T,\n      message: \"Success\",\n      meta: {},\n    };\n  }\n\n  /**\n   * Convenience method for raw responses\n   */\n  async requestRaw<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    const response = await this.request<T>(endpoint, options, \"auto\");\n\n    if (isApiResponse<T>(response)) {\n      return response.data;\n    }\n\n    return response as T;\n  }\n\n  /**\n   * GET request\n   */\n  async get<T>(\n    endpoint: string,\n    params?: Record<string, string | number | boolean | null | undefined>,\n    options: RequestInit = {}\n  ): Promise<HttpResponse<T>> {\n    let url = endpoint;\n\n    if (params) {\n      const searchParams = new URLSearchParams();\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== null && value !== undefined) {\n          searchParams.append(key, value.toString());\n        }\n      });\n      const queryString = searchParams.toString();\n      if (queryString) {\n        url += `?${queryString}`;\n      }\n    }\n\n    return this.request<T>(url, {\n      method: \"GET\",\n      ...options,\n    });\n  }\n\n  /**\n   * POST request\n   */\n  async post<T>(\n    endpoint: string,\n    body?: unknown,\n    options: RequestInit = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \"POST\",\n      body: body ? JSON.stringify(body) : undefined,\n      ...options,\n    });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T>(\n    endpoint: string,\n    body?: unknown,\n    options: RequestInit = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \"PUT\",\n      body: body ? JSON.stringify(body) : undefined,\n      ...options,\n    });\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch<T>(\n    endpoint: string,\n    body?: unknown,\n    options: RequestInit = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \"PATCH\",\n      body: body ? JSON.stringify(body) : undefined,\n      ...options,\n    });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(\n    endpoint: string,\n    body?: unknown,\n    options: RequestInit = {}\n  ): Promise<HttpResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \"DELETE\",\n      body: body ? JSON.stringify(body) : undefined,\n      ...options,\n    });\n  }\n\n  /**\n   * Update client configuration\n   */\n  updateConfig(config: Partial<HttpClientConfig>): void {\n    if (config.baseUrl !== undefined) {\n      this.baseUrl = config.baseUrl.replace(/\\/$/, \"\");\n    }\n    if (config.headers) {\n      this.headers = {\n        ...this.headers,\n        ...config.headers,\n      };\n    }\n    if (config.timeout !== undefined) {\n      this.timeout = config.timeout;\n    }\n    if (config.defaultResponseFormat !== undefined) {\n      this.defaultResponseFormat = config.defaultResponseFormat;\n    }\n    if (config.retries !== undefined) {\n      this.retries = config.retries;\n    }\n    if (config.retryDelay !== undefined) {\n      this.retryDelay = config.retryDelay;\n    }\n    if (config.retryOnStatus !== undefined) {\n      this.retryOnStatus = config.retryOnStatus;\n    }\n    if (config.onRequest !== undefined) {\n      this.onRequest = config.onRequest;\n    }\n    if (config.onResponse !== undefined) {\n      this.onResponse = config.onResponse;\n    }\n    if (config.onError !== undefined) {\n      this.onError = config.onError;\n    }\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): HttpClientConfig {\n    return {\n      baseUrl: this.baseUrl,\n      headers: { ...this.headers },\n      timeout: this.timeout,\n      defaultResponseFormat: this.defaultResponseFormat,\n      retries: this.retries,\n      retryDelay: this.retryDelay,\n      retryOnStatus: [...this.retryOnStatus],\n    };\n  }\n}\n\n/**\n * Factory function to create pre-configured clients for common patterns\n */\nexport const createHttpClient = {\n  /**\n   * Standard client with Authorization header\n   */\n  withAuth(token: string, config?: HttpClientConfig): HttpClient {\n    return new HttpClient({\n      ...config,\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...config?.headers,\n      },\n    });\n  },\n\n  /**\n   * Client with API key\n   */\n  withApiKey(\n    apiKey: string,\n    headerName: string = \"X-API-Key\",\n    config?: HttpClientConfig\n  ): HttpClient {\n    return new HttpClient({\n      ...config,\n      headers: {\n        [headerName]: apiKey,\n        ...config?.headers,\n      },\n    });\n  },\n\n  /**\n   * Client with custom auth headers (like your original setup)\n   */\n  withCustomAuth(\n    authToken: string,\n    appId?: string,\n    config?: HttpClientConfig\n  ): HttpClient {\n    const headers: Record<string, string> = {\n      \"auth-token\": authToken,\n      ...config?.headers,\n    };\n\n    if (appId) {\n      headers[\"app-id\"] = appId;\n    }\n\n    return new HttpClient({\n      ...config,\n      headers,\n    });\n  },\n\n  /**\n   * Client with basic auth\n   */\n  withBasicAuth(\n    username: string,\n    password: string,\n    config?: HttpClientConfig\n  ): HttpClient {\n    const credentials = btoa(`${username}:${password}`);\n    return new HttpClient({\n      ...config,\n      headers: {\n        Authorization: `Basic ${credentials}`,\n        ...config?.headers,\n      },\n    });\n  },\n};\n",
      "type": "registry:lib",
      "target": "utils/aevr/http-client.ts"
    }
  ]
}