{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "date-formatter",
  "type": "registry:lib",
  "title": "Date Formatter",
  "description": "A utility function for formatting dates and times.",
  "dependencies": [
    "@untools/logger",
    "date-fns",
    "date-fns-tz"
  ],
  "files": [
    {
      "path": "registry/lagos/utils/date-formatter.ts",
      "content": "// ./utils/dateFormatter.ts\n\nimport { logger } from \"@untools/logger\";\nimport {\n  format,\n  parseISO,\n  isValid,\n  fromUnixTime,\n  formatDistanceToNow,\n} from \"date-fns\";\nimport { formatInTimeZone } from \"date-fns-tz\";\nimport * as locales from \"date-fns/locale\";\n\ntype DateInput = string | number | Date;\n\ninterface FormatDateOptions {\n  formatStyle?: \"absolute\" | \"relative\";\n  formatString?: string; // for absolute\n  locale?: keyof typeof locales;\n  timeZone?: string; // e.g., \"America/New_York\"\n}\n\n/**\n * Formats a date with options for relative time, timezones, and localization.\n */\nexport function formatDate(\n  input: DateInput | null | undefined,\n  {\n    formatStyle = \"relative\",\n    formatString = \"PPP\",\n    locale = \"enUS\",\n    timeZone,\n  }: FormatDateOptions = {}\n): string {\n  logger.debug({\n    input,\n    formatStyle,\n    formatString,\n    locale,\n    timeZone,\n    type: typeof input,\n  });\n\n  if (!input) {\n    logger.warn({ message: \"No date input provided\", input });\n    return \"N/A\";\n  }\n\n  let date: Date;\n\n  // Handle different input types\n  if (typeof input === \"string\") {\n    // Check if the string is a numeric timestamp\n    if (/^\\d+$/.test(input)) {\n      // Convert string timestamp to number and create Date\n      const timestamp = parseInt(input, 10);\n\n      // Check if it's seconds or milliseconds\n      // Most Unix timestamps are in seconds (10 digits for recent dates)\n      // While JavaScript uses milliseconds (13 digits for recent dates)\n      if (input.length <= 10) {\n        // Assuming seconds, convert to milliseconds\n        date = fromUnixTime(timestamp);\n      } else {\n        // Assuming milliseconds\n        date = new Date(timestamp);\n      }\n    } else {\n      // Try to parse as ISO date string\n      date = parseISO(input);\n    }\n  } else if (typeof input === \"number\") {\n    // For number inputs, check if seconds or milliseconds\n    if (input < 10000000000) {\n      // Rough threshold for seconds vs milliseconds\n      date = fromUnixTime(input);\n    } else {\n      date = new Date(input);\n    }\n  } else {\n    // Already a Date object\n    date = input;\n  }\n\n  // Check if the date is valid\n  if (!isValid(date)) {\n    logger.warn({ message: \"Invalid date encountered\", input });\n    return \"Invalid date\";\n  }\n\n  const localeObj = locales[locale] || locales.enUS;\n\n  if (formatStyle === \"relative\") {\n    return formatDistanceToNow(date, { addSuffix: true, locale: localeObj });\n  }\n\n  if (timeZone) {\n    return formatInTimeZone(date, timeZone, formatString, {\n      locale: localeObj,\n    });\n  }\n\n  return format(date, formatString, { locale: localeObj });\n}\n\n/**\n * Common date-time format presets\n */\nexport enum DateTimePreset {\n  SHORT = \"short\",\n  MEDIUM = \"medium\",\n  LONG = \"long\",\n  FULL = \"full\",\n  ISO = \"iso\",\n  SIMPLE = \"simple\",\n  TIME_ONLY = \"timeOnly\",\n  DATE_ONLY = \"dateOnly\",\n  CUSTOM = \"custom\",\n}\n\n/**\n * Enhanced datetime formatter with preset formats and better options\n */\nexport function formatDateTime(\n  input: DateInput,\n  options: {\n    preset?: DateTimePreset;\n    formatString?: string;\n    locale?: keyof typeof locales;\n    timeZone?: string;\n    includeSeconds?: boolean;\n    use24HourFormat?: boolean;\n  } = {}\n): string {\n  const {\n    preset = DateTimePreset.MEDIUM,\n    formatString,\n    locale = \"enUS\",\n    timeZone,\n    includeSeconds = false,\n    use24HourFormat = false,\n  } = options;\n\n  // If custom format is provided, use it directly\n  if (formatString) {\n    return formatDate(input, {\n      formatStyle: \"absolute\",\n      formatString,\n      locale,\n      timeZone,\n    });\n  }\n\n  // Define format patterns based on presets\n  const formatPatterns: Record<DateTimePreset, string> = {\n    [DateTimePreset.SHORT]: use24HourFormat\n      ? `dd/MM/yyyy ${includeSeconds ? \"HH:mm:ss\" : \"HH:mm\"}`\n      : `MM/dd/yyyy ${includeSeconds ? \"h:mm:ss a\" : \"h:mm a\"}`,\n    [DateTimePreset.MEDIUM]: use24HourFormat\n      ? `d MMM yyyy ${includeSeconds ? \"HH:mm:ss\" : \"HH:mm\"}`\n      : `MMM d, yyyy ${includeSeconds ? \"h:mm:ss a\" : \"h:mm a\"}`,\n    [DateTimePreset.LONG]: use24HourFormat\n      ? `d MMMM yyyy ${includeSeconds ? \"HH:mm:ss\" : \"HH:mm\"}`\n      : `MMMM d, yyyy ${includeSeconds ? \"h:mm:ss a\" : \"h:mm a\"}`,\n    [DateTimePreset.FULL]: use24HourFormat\n      ? `EEEE, d MMMM yyyy ${includeSeconds ? \"HH:mm:ss\" : \"HH:mm\"}`\n      : `EEEE, MMMM d, yyyy ${includeSeconds ? \"h:mm:ss a\" : \"h:mm a\"}`,\n    [DateTimePreset.ISO]: \"yyyy-MM-dd'T'HH:mm:ss.SSSxxx\",\n    [DateTimePreset.SIMPLE]: \"yyyy-MM-dd HH:mm:ss\",\n    [DateTimePreset.TIME_ONLY]: use24HourFormat\n      ? includeSeconds\n        ? \"HH:mm:ss\"\n        : \"HH:mm\"\n      : includeSeconds\n      ? \"h:mm:ss a\"\n      : \"h:mm a\",\n    [DateTimePreset.DATE_ONLY]: \"yyyy-MM-dd\",\n    [DateTimePreset.CUSTOM]: formatString || \"yyyy-MM-dd HH:mm:ss\", // Fallback\n  };\n\n  return formatDate(input, {\n    formatStyle: \"absolute\",\n    formatString: formatPatterns[preset],\n    locale,\n    timeZone,\n  });\n}\n\n/**\n * Formats a date as a relative time (e.g., \"2 hours ago\", \"in 3 days\")\n */\nexport function formatRelativeTime(\n  input: DateInput,\n  options: {\n    locale?: keyof typeof locales;\n  } = {}\n): string {\n  return formatDate(input, {\n    formatStyle: \"relative\",\n    locale: options.locale,\n  });\n}\n\n/**\n * Returns a user-friendly date and time representation with smart formatting\n * If the date is today, it returns only the time\n * If the date is this year, it omits the year\n * Otherwise returns the full date and time\n */\nexport function formatSmartDateTime(\n  input: DateInput,\n  options: {\n    locale?: keyof typeof locales;\n    timeZone?: string;\n    use24HourFormat?: boolean;\n    includeSeconds?: boolean;\n  } = {}\n): string {\n  const {\n    locale = \"enUS\",\n    timeZone,\n    use24HourFormat = false,\n    includeSeconds = false,\n  } = options;\n\n  const date = ensureDate(input);\n  if (!isValid(date)) return \"Invalid date\";\n\n  const now = new Date();\n  const isToday =\n    date.getDate() === now.getDate() &&\n    date.getMonth() === now.getMonth() &&\n    date.getFullYear() === now.getFullYear();\n\n  const isThisYear = date.getFullYear() === now.getFullYear();\n\n  const timeFormat = use24HourFormat\n    ? includeSeconds\n      ? \"HH:mm:ss\"\n      : \"HH:mm\"\n    : includeSeconds\n    ? \"h:mm:ss a\"\n    : \"h:mm a\";\n\n  let formatString;\n  if (isToday) {\n    formatString = timeFormat;\n  } else if (isThisYear) {\n    formatString = `MMM d, ${timeFormat}`;\n  } else {\n    formatString = `MMM d, yyyy, ${timeFormat}`;\n  }\n\n  return formatDate(date, {\n    formatStyle: \"absolute\",\n    formatString,\n    locale,\n    timeZone,\n  });\n}\n\n/**\n * Helper function to ensure we have a valid Date object\n */\nfunction ensureDate(input: DateInput): Date {\n  if (typeof input === \"string\") {\n    if (/^\\d+$/.test(input)) {\n      const timestamp = parseInt(input, 10);\n      return input.length <= 10 ? fromUnixTime(timestamp) : new Date(timestamp);\n    }\n    return parseISO(input);\n  } else if (typeof input === \"number\") {\n    return input < 10000000000 ? fromUnixTime(input) : new Date(input);\n  }\n  return input;\n}\n",
      "type": "registry:lib",
      "target": "utils/aevr/date-formatter.ts"
    }
  ]
}