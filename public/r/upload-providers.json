{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "upload-providers",
  "type": "registry:lib",
  "title": "Upload Providers",
  "description": "A utility function for creating upload providers.",
  "registryDependencies": [
    "@aevr/file-upload"
  ],
  "files": [
    {
      "path": "registry/utils/upload-providers.ts",
      "content": "// ./registry/lagos/utils/upload-providers.ts\n\nimport {\n  CloudinaryProvider,\n  S3Provider,\n  UploadProvider,\n  UploadResponse,\n} from \"@/registry/lagos/ui/file-upload\";\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\ninterface FirebaseStorage {\n  ref: () => FirebaseStorageReference;\n}\n\ninterface FirebaseStorageReference {\n  child: (path: string) => FirebaseStorageReference;\n  put: (\n    file: File,\n    metadata?: FirebaseUploadMetadata\n  ) => Promise<FirebaseUploadTaskSnapshot>;\n}\n\ninterface FirebaseUploadMetadata {\n  contentType?: string;\n  customMetadata?: Record<string, string>;\n}\n\ninterface FirebaseUploadTaskSnapshot {\n  ref: {\n    getDownloadURL: () => Promise<string>;\n    fullPath: string;\n    name: string;\n    bucket: string;\n  };\n  metadata: {\n    size: number;\n    timeCreated: string;\n  };\n}\n\ninterface PinataMetadata {\n  name?: string;\n  keyvalues?: Record<string, string | number | boolean>;\n}\n\ninterface ImageKitOptions {\n  fileName?: string;\n  folder?: string;\n  tags?: string[];\n  customMetadata?: Record<string, string | number | boolean>;\n}\n\ninterface BackblazeAuthResponse {\n  authorizationToken: string;\n  apiUrl: string;\n}\n\ninterface BackblazeUploadUrlResponse {\n  uploadUrl: string;\n  authorizationToken: string;\n}\n\ninterface BackblazeUploadResponse {\n  fileId: string;\n  fileName: string;\n  accountId: string;\n  bucketId: string;\n  contentLength: number;\n  uploadTimestamp: number;\n  message?: string;\n}\n\n// ============================================================================\n// Base64 Provider (for local storage/processing)\n// ============================================================================\n\nexport class Base64Provider implements UploadProvider {\n  name = \"base64\";\n\n  async uploadFile(file: File): Promise<UploadResponse> {\n    try {\n      const base64 = await this.convertToBase64(file);\n      return {\n        success: true,\n        data: {\n          base64,\n          dataUrl: `data:${file.type};base64,${base64}`,\n          name: file.name,\n          size: file.size,\n          type: file.type,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  private convertToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => {\n        const base64 = reader.result as string;\n        const base64Data = base64.split(\",\")[1];\n        resolve(base64Data);\n      };\n      reader.onerror = reject;\n    });\n  }\n}\n\n// ============================================================================\n// Supabase Storage Provider\n// ============================================================================\n\nexport class SupabaseProvider implements UploadProvider {\n  name = \"supabase\";\n  private supabaseUrl: string;\n  private supabaseKey: string;\n  private bucketName: string;\n\n  constructor(supabaseUrl: string, supabaseKey: string, bucketName: string) {\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    this.bucketName = bucketName;\n  }\n\n  async uploadFile(\n    file: File,\n    options: { path?: string; upsert?: boolean } = {}\n  ): Promise<UploadResponse> {\n    try {\n      const { path = `uploads/${Date.now()}-${file.name}`, upsert = false } =\n        options;\n\n      const response = await fetch(\n        `${this.supabaseUrl}/storage/v1/object/${this.bucketName}/${path}`,\n        {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            \"Content-Type\": file.type,\n            \"x-upsert\": upsert.toString(),\n          },\n          body: file,\n        }\n      );\n\n      if (!response.ok) {\n        const error = await response.json();\n        return {\n          success: false,\n          error: error.message || \"Upload failed\",\n        };\n      }\n\n      const publicUrl = `${this.supabaseUrl}/storage/v1/object/public/${this.bucketName}/${path}`;\n\n      return {\n        success: true,\n        data: {\n          path,\n          fullPath: `${this.bucketName}/${path}`,\n          publicUrl,\n          name: file.name,\n          size: file.size,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// Firebase Storage Provider\n// ============================================================================\n\nexport class FirebaseProvider implements UploadProvider {\n  name = \"firebase\";\n  private storage: FirebaseStorage;\n  private bucketName?: string;\n\n  constructor(firebaseStorage: FirebaseStorage, bucketName?: string) {\n    this.storage = firebaseStorage;\n    this.bucketName = bucketName;\n  }\n\n  async uploadFile(\n    file: File,\n    options: { path?: string; metadata?: Record<string, string> } = {}\n  ): Promise<UploadResponse> {\n    try {\n      const { path = `uploads/${Date.now()}-${file.name}`, metadata = {} } =\n        options;\n\n      // Create a reference\n      const storageRef = this.storage.ref();\n      const fileRef = storageRef.child(path);\n\n      // Upload the file\n      const snapshot = await fileRef.put(file, {\n        contentType: file.type,\n        customMetadata: metadata,\n      });\n\n      // Get download URL\n      const downloadURL = await snapshot.ref.getDownloadURL();\n\n      return {\n        success: true,\n        data: {\n          path,\n          downloadURL,\n          fullPath: snapshot.ref.fullPath,\n          name: snapshot.ref.name,\n          bucket: snapshot.ref.bucket,\n          size: snapshot.metadata.size,\n          timeCreated: snapshot.metadata.timeCreated,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// Uploadcare Provider\n// ============================================================================\n\nexport class UploadcareProvider implements UploadProvider {\n  name = \"uploadcare\";\n  private publicKey: string;\n\n  constructor(publicKey: string) {\n    this.publicKey = publicKey;\n  }\n\n  async uploadFile(\n    file: File,\n    options: { store?: boolean; metadata?: Record<string, string> } = {}\n  ): Promise<UploadResponse> {\n    try {\n      const { store = true, metadata = {} } = options;\n\n      const formData = new FormData();\n      formData.append(\"UPLOADCARE_PUB_KEY\", this.publicKey);\n      formData.append(\"UPLOADCARE_STORE\", store ? \"1\" : \"0\");\n      formData.append(\"file\", file);\n\n      // Add metadata\n      Object.entries(metadata).forEach(([key, value]) => {\n        formData.append(`metadata[${key}]`, value);\n      });\n\n      const response = await fetch(\"https://upload.uploadcare.com/base/\", {\n        method: \"POST\",\n        body: formData,\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: data.error?.content || \"Upload failed\",\n        };\n      }\n\n      return {\n        success: true,\n        data: {\n          uuid: data.file,\n          cdnUrl: `https://ucarecdn.com/${data.file}/`,\n          originalUrl: `https://ucarecdn.com/${data.file}/-/preview/`,\n          name: file.name,\n          size: file.size,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// Pinata IPFS Provider\n// ============================================================================\n\nexport class PinataProvider implements UploadProvider {\n  name = \"pinata\";\n  private apiKey: string;\n  private secretKey: string;\n\n  constructor(apiKey: string, secretKey: string) {\n    this.apiKey = apiKey;\n    this.secretKey = secretKey;\n  }\n\n  async uploadFile(\n    file: File,\n    options: {\n      metadata?: PinataMetadata;\n    } = {}\n  ): Promise<UploadResponse> {\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      if (options.metadata) {\n        formData.append(\"pinataMetadata\", JSON.stringify(options.metadata));\n      }\n\n      const response = await fetch(\n        \"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n        {\n          method: \"POST\",\n          headers: {\n            pinata_api_key: this.apiKey,\n            pinata_secret_api_key: this.secretKey,\n          },\n          body: formData,\n        }\n      );\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: data.error || \"Upload failed\",\n        };\n      }\n\n      return {\n        success: true,\n        data: {\n          ipfsHash: data.IpfsHash,\n          pinSize: data.PinSize,\n          timestamp: data.Timestamp,\n          gatewayUrl: `https://gateway.pinata.cloud/ipfs/${data.IpfsHash}`,\n          name: file.name,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// ImageKit Provider\n// ============================================================================\n\nexport class ImageKitProvider implements UploadProvider {\n  name = \"imagekit\";\n  private endpoint: string;\n  private publicKey: string;\n  private authEndpoint: string;\n\n  constructor(endpoint: string, publicKey: string, authEndpoint: string) {\n    this.endpoint = endpoint;\n    this.publicKey = publicKey;\n    this.authEndpoint = authEndpoint;\n  }\n\n  async uploadFile(\n    file: File,\n    options: ImageKitOptions = {}\n  ): Promise<UploadResponse> {\n    try {\n      // Get authentication parameters\n      const authResponse = await fetch(this.authEndpoint);\n      const authData = await authResponse.json();\n\n      const formData = new FormData();\n      formData.append(\"file\", file);\n      formData.append(\"publicKey\", this.publicKey);\n      formData.append(\"signature\", authData.signature);\n      formData.append(\"expire\", authData.expire);\n      formData.append(\"token\", authData.token);\n\n      // Add optional parameters\n      if (options.fileName) {\n        formData.append(\"fileName\", options.fileName);\n      }\n      if (options.folder) {\n        formData.append(\"folder\", options.folder);\n      }\n      if (options.tags && options.tags.length > 0) {\n        formData.append(\"tags\", options.tags.join(\",\"));\n      }\n      if (options.customMetadata) {\n        formData.append(\n          \"customMetadata\",\n          JSON.stringify(options.customMetadata)\n        );\n      }\n\n      const response = await fetch(`${this.endpoint}/api/v1/files/upload`, {\n        method: \"POST\",\n        body: formData,\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        return {\n          success: false,\n          error: data.message || \"Upload failed\",\n        };\n      }\n\n      return {\n        success: true,\n        data: {\n          fileId: data.fileId,\n          name: data.name,\n          url: data.url,\n          thumbnailUrl: data.thumbnailUrl,\n          filePath: data.filePath,\n          size: data.size,\n          fileType: data.fileType,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// Backblaze B2 Provider\n// ============================================================================\n\nexport class BackblazeProvider implements UploadProvider {\n  name = \"backblaze\";\n  private applicationKeyId: string;\n  private applicationKey: string;\n  private bucketId: string;\n\n  constructor(\n    applicationKeyId: string,\n    applicationKey: string,\n    bucketId: string\n  ) {\n    this.applicationKeyId = applicationKeyId;\n    this.applicationKey = applicationKey;\n    this.bucketId = bucketId;\n  }\n\n  async uploadFile(\n    file: File,\n    options: { fileName?: string; contentType?: string } = {}\n  ): Promise<UploadResponse> {\n    try {\n      // First, get authorization\n      const authResponse = await fetch(\n        \"https://api.backblazeb2.com/b2api/v2/b2_authorize_account\",\n        {\n          method: \"GET\",\n          headers: {\n            Authorization: `Basic ${btoa(\n              `${this.applicationKeyId}:${this.applicationKey}`\n            )}`,\n          },\n        }\n      );\n\n      if (!authResponse.ok) {\n        throw new Error(\"Failed to authorize with Backblaze\");\n      }\n\n      const authData: BackblazeAuthResponse = await authResponse.json();\n\n      // Get upload URL\n      const uploadUrlResponse = await fetch(\n        `${authData.apiUrl}/b2api/v2/b2_get_upload_url`,\n        {\n          method: \"POST\",\n          headers: {\n            Authorization: authData.authorizationToken,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            bucketId: this.bucketId,\n          }),\n        }\n      );\n\n      const uploadUrlData: BackblazeUploadUrlResponse =\n        await uploadUrlResponse.json();\n\n      // Upload file\n      const fileName = options.fileName || file.name;\n      const contentType = options.contentType || file.type;\n\n      const uploadResponse = await fetch(uploadUrlData.uploadUrl, {\n        method: \"POST\",\n        headers: {\n          Authorization: uploadUrlData.authorizationToken,\n          \"X-Bz-File-Name\": fileName,\n          \"Content-Type\": contentType,\n          \"X-Bz-Content-Sha1\": \"unverified\",\n        },\n        body: file,\n      });\n\n      const uploadData: BackblazeUploadResponse = await uploadResponse.json();\n\n      if (!uploadResponse.ok) {\n        return {\n          success: false,\n          error: uploadData.message || \"Upload failed\",\n        };\n      }\n\n      return {\n        success: true,\n        data: {\n          fileId: uploadData.fileId,\n          fileName: uploadData.fileName,\n          accountId: uploadData.accountId,\n          bucketId: uploadData.bucketId,\n          contentLength: uploadData.contentLength,\n          uploadTimestamp: uploadData.uploadTimestamp,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n\n// ============================================================================\n// Provider Factory and Helpers\n// ============================================================================\n\nexport interface ProviderConfig {\n  type:\n    | \"s3\"\n    | \"cloudinary\"\n    | \"supabase\"\n    | \"firebase\"\n    | \"uploadcare\"\n    | \"pinata\"\n    | \"imagekit\"\n    | \"backblaze\"\n    | \"base64\"\n    | \"custom\";\n  config: Record<string, unknown>;\n}\n\n// Import types for dynamic imports\ntype S3ProviderClass = typeof import(\"../lagos/ui/file-upload\").S3Provider;\ntype CloudinaryProviderClass =\n  typeof import(\"../lagos/ui/file-upload\").CloudinaryProvider;\ntype CustomAPIProviderClass =\n  typeof import(\"../lagos/ui/file-upload\").CustomAPIProvider;\n\nexport class ProviderFactory {\n  static async create(providerConfig: ProviderConfig): Promise<UploadProvider> {\n    switch (providerConfig.type) {\n      case \"s3\": {\n        const { S3Provider } = await import(\"../lagos/ui/file-upload\");\n        return new (S3Provider as unknown as S3ProviderClass)(\n          providerConfig.config.baseUrl as string,\n          providerConfig.config.apiKey as string\n        );\n      }\n\n      case \"cloudinary\": {\n        const { CloudinaryProvider } = await import(\"../lagos/ui/file-upload\");\n        return new (CloudinaryProvider as unknown as CloudinaryProviderClass)(\n          providerConfig.config.cloudName as string,\n          providerConfig.config.apiKey as string\n        );\n      }\n\n      case \"supabase\":\n        return new SupabaseProvider(\n          providerConfig.config.supabaseUrl as string,\n          providerConfig.config.supabaseKey as string,\n          providerConfig.config.bucketName as string\n        );\n\n      case \"firebase\":\n        return new FirebaseProvider(\n          providerConfig.config.storage as FirebaseStorage,\n          providerConfig.config.bucketName as string | undefined\n        );\n\n      case \"uploadcare\":\n        return new UploadcareProvider(\n          providerConfig.config.publicKey as string\n        );\n\n      case \"pinata\":\n        return new PinataProvider(\n          providerConfig.config.apiKey as string,\n          providerConfig.config.secretKey as string\n        );\n\n      case \"imagekit\":\n        return new ImageKitProvider(\n          providerConfig.config.endpoint as string,\n          providerConfig.config.publicKey as string,\n          providerConfig.config.authEndpoint as string\n        );\n\n      case \"backblaze\":\n        return new BackblazeProvider(\n          providerConfig.config.applicationKeyId as string,\n          providerConfig.config.applicationKey as string,\n          providerConfig.config.bucketId as string\n        );\n\n      case \"base64\":\n        return new Base64Provider();\n\n      case \"custom\": {\n        const { CustomAPIProvider } = await import(\"../lagos/ui/file-upload\");\n        return new (CustomAPIProvider as unknown as CustomAPIProviderClass)(\n          providerConfig.config.endpoint as string,\n          providerConfig.config.headers as Record<string, string>\n        );\n      }\n\n      default:\n        throw new Error(`Unsupported provider type: ${providerConfig.type}`);\n    }\n  }\n}\n\n// ============================================================================\n// Multi-Provider Upload (for redundancy/backup)\n// ============================================================================\n\nexport class MultiProvider implements UploadProvider {\n  name = \"multi\";\n  private providers: UploadProvider[];\n  private strategy: \"all\" | \"first-success\" | \"primary-fallback\";\n  private primaryIndex: number;\n\n  constructor(\n    providers: UploadProvider[],\n    strategy: \"all\" | \"first-success\" | \"primary-fallback\" = \"first-success\",\n    primaryIndex: number = 0\n  ) {\n    this.providers = providers;\n    this.strategy = strategy;\n    this.primaryIndex = primaryIndex;\n  }\n\n  async uploadFile(\n    file: File,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    switch (this.strategy) {\n      case \"all\":\n        return this.uploadToAll(file, options);\n      case \"first-success\":\n        return this.uploadFirstSuccess(file, options);\n      case \"primary-fallback\":\n        return this.uploadPrimaryFallback(file, options);\n      default:\n        return this.uploadFirstSuccess(file, options);\n    }\n  }\n\n  private async uploadToAll(\n    file: File,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    const results = await Promise.allSettled(\n      this.providers.map((provider) => provider.uploadFile(file, options))\n    );\n\n    const successful = results\n      .filter(\n        (result): result is PromiseFulfilledResult<UploadResponse> =>\n          result.status === \"fulfilled\" && result.value.success\n      )\n      .map((result) => result.value);\n\n    const failed = results.filter(\n      (\n        result\n      ): result is\n        | PromiseRejectedResult\n        | PromiseFulfilledResult<UploadResponse> =>\n        result.status === \"rejected\" ||\n        (result.status === \"fulfilled\" && !result.value.success)\n    );\n\n    if (successful.length === 0) {\n      return {\n        success: false,\n        error: `All providers failed: ${failed\n          .map((r) =>\n            r.status === \"rejected\"\n              ? r.reason\n              : (r as PromiseFulfilledResult<UploadResponse>).value.error\n          )\n          .join(\", \")}`,\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        results: successful.map((result) => result.data),\n        primary: successful[0].data,\n        successCount: successful.length,\n        failureCount: failed.length,\n      },\n    };\n  }\n\n  private async uploadFirstSuccess(\n    file: File,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    const errors: string[] = [];\n\n    for (const provider of this.providers) {\n      try {\n        const result = await provider.uploadFile(file, options);\n        if (result.success) {\n          return result;\n        }\n        errors.push(`${provider.name}: ${result.error}`);\n      } catch (error) {\n        errors.push(`${provider.name}: ${(error as Error).message}`);\n      }\n    }\n\n    return {\n      success: false,\n      error: `All providers failed: ${errors.join(\", \")}`,\n    };\n  }\n\n  private async uploadPrimaryFallback(\n    file: File,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    const primary = this.providers[this.primaryIndex];\n    if (!primary) {\n      return {\n        success: false,\n        error: \"No primary provider configured\",\n      };\n    }\n\n    try {\n      const result = await primary.uploadFile(file, options);\n      if (result.success) {\n        return result;\n      }\n    } catch {\n      // Continue to fallback - removed unused error parameter\n    }\n\n    // Try other providers as fallback\n    const fallbackProviders = this.providers.filter(\n      (_, index) => index !== this.primaryIndex\n    );\n    return this.uploadFirstSuccessFromProviders(\n      fallbackProviders,\n      file,\n      options\n    );\n  }\n\n  private async uploadFirstSuccessFromProviders(\n    providers: UploadProvider[],\n    file: File,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    const errors: string[] = [];\n\n    for (const provider of providers) {\n      try {\n        const result = await provider.uploadFile(file, options);\n        if (result.success) {\n          return result;\n        }\n        errors.push(`${provider.name}: ${result.error}`);\n      } catch (error) {\n        errors.push(`${provider.name}: ${(error as Error).message}`);\n      }\n    }\n\n    return {\n      success: false,\n      error: `All fallback providers failed: ${errors.join(\", \")}`,\n    };\n  }\n}\n\n// ============================================================================\n// Upload Queue Manager (for handling multiple files efficiently)\n// ============================================================================\n\nexport class UploadQueue {\n  private queue: Array<{\n    file: File;\n    provider: UploadProvider;\n    options?: Record<string, unknown>;\n    resolve: (value: UploadResponse) => void;\n    reject: (error: Error) => void;\n  }> = [];\n  private isProcessing = false;\n  private concurrency = 3;\n  private activeUploads = 0;\n\n  constructor(concurrency = 3) {\n    this.concurrency = concurrency;\n  }\n\n  async add(\n    file: File,\n    provider: UploadProvider,\n    options?: Record<string, unknown>\n  ): Promise<UploadResponse> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ file, provider, options, resolve, reject });\n      this.process();\n    });\n  }\n\n  private async process() {\n    if (this.isProcessing || this.activeUploads >= this.concurrency) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    while (this.queue.length > 0 && this.activeUploads < this.concurrency) {\n      const item = this.queue.shift();\n      if (item) {\n        this.activeUploads++;\n        this.processItem(item);\n      }\n    }\n\n    this.isProcessing = false;\n  }\n\n  private async processItem(item: {\n    file: File;\n    provider: UploadProvider;\n    options?: Record<string, unknown>;\n    resolve: (value: UploadResponse) => void;\n    reject: (error: Error) => void;\n  }) {\n    try {\n      const result = await item.provider.uploadFile(item.file, item.options);\n      item.resolve(result);\n    } catch (error) {\n      item.reject(error as Error);\n    } finally {\n      this.activeUploads--;\n      // Continue processing if there are more items\n      if (this.queue.length > 0) {\n        this.process();\n      }\n    }\n  }\n\n  getQueueLength(): number {\n    return this.queue.length;\n  }\n\n  getActiveUploads(): number {\n    return this.activeUploads;\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\nexport const createProviderFromEnv = (type: string): UploadProvider | null => {\n  switch (type.toLowerCase()) {\n    case \"s3\":\n      if (\n        process.env.NEXT_PUBLIC_S3_ENDPOINT &&\n        process.env.NEXT_PUBLIC_S3_API_KEY\n      ) {\n        return new S3Provider(\n          process.env.NEXT_PUBLIC_S3_ENDPOINT,\n          process.env.NEXT_PUBLIC_S3_API_KEY\n        ) as UploadProvider;\n      }\n      break;\n\n    case \"cloudinary\":\n      if (\n        process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME &&\n        process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY\n      ) {\n        return new CloudinaryProvider(\n          process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME,\n          process.env.NEXT_PUBLIC_CLOUDINARY_API_KEY\n        ) as UploadProvider;\n      }\n      break;\n\n    case \"supabase\":\n      if (\n        process.env.NEXT_PUBLIC_SUPABASE_URL &&\n        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n      ) {\n        return new SupabaseProvider(\n          process.env.NEXT_PUBLIC_SUPABASE_URL,\n          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,\n          process.env.NEXT_PUBLIC_SUPABASE_BUCKET || \"uploads\"\n        );\n      }\n      break;\n\n    default:\n      return null;\n  }\n\n  return null;\n};\n",
      "type": "registry:lib",
      "target": "utils/aevr/upload-providers.ts"
    }
  ]
}