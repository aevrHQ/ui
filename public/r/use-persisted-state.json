{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-persisted-state",
  "type": "registry:hook",
  "title": "Use Persisted State",
  "description": "A hook for persisting state in local storage.",
  "dependencies": [
    "@untools/logger",
    "zustand"
  ],
  "files": [
    {
      "path": "registry/lagos/hooks/use-persisted-state.ts",
      "content": "// hooks/usePersistedState.ts\nimport { create, StateCreator, StoreApi, UseBoundStore } from \"zustand\";\nimport { createJSONStorage, persist } from \"zustand/middleware\";\n\n/** Helper alias for a bound store of a given state */\ntype BoundStore<S> = UseBoundStore<StoreApi<S>>;\n\n/**\n * Registry to track created stores and prevent duplicates\n * Key: storageKey, Value: zustand bound store instance\n */\nconst storeRegistry = new Map<string, BoundStore<unknown>>();\n\n/**\n * Internal store structure that wraps user state with persistence metadata\n */\ninterface PersistedStore<TState> {\n  userState: TState;\n  isHydrated: boolean;\n  setUserState: (newState: TState | ((prev: TState) => TState)) => void;\n  resetToInitial: () => void;\n  markAsHydrated: (hydrated: boolean) => void;\n}\n\n/**\n * Configuration options for persisted state behavior\n */\nexport interface PersistedStateOptions<TState = unknown> {\n  storageKey: string;\n  enablePersistence?: boolean;\n  selectForPersistence?: (state: TState) => Partial<TState>;\n  storage?: Storage;\n}\n\n/**\n * Return type for the usePersistedState hook\n */\nexport interface PersistedStateResult<TState> {\n  state: TState;\n  setState: (newState: TState | ((prev: TState) => TState)) => void;\n  resetState: () => void;\n  isHydrated: boolean;\n}\n\n/**\n * A useState-like hook that provides global, optionally persisted state.\n */\nexport const usePersistedState = <TState = unknown>(\n  initialStateOrOptions: TState | PersistedStateOptions<TState>,\n  optionsParam?: PersistedStateOptions<TState>\n): PersistedStateResult<TState> => {\n  // Handle overloaded parameters\n  let initialState: TState;\n  let options: PersistedStateOptions<TState>;\n\n  if (optionsParam) {\n    initialState = initialStateOrOptions as TState;\n    options = optionsParam;\n  } else {\n    initialState = undefined as TState;\n    options = initialStateOrOptions as PersistedStateOptions<TState>;\n  }\n\n  const {\n    storageKey,\n    enablePersistence = true,\n    selectForPersistence,\n    storage = typeof window !== \"undefined\" ? window.localStorage : undefined,\n  } = options;\n\n  if (!storageKey) {\n    throw new Error(\"usePersistedState: storageKey is required\");\n  }\n\n  // Return existing store if already created\n  if (storeRegistry.has(storageKey)) {\n    const existingStore = storeRegistry.get(storageKey)! as BoundStore<\n      PersistedStore<TState>\n    >;\n    return createStoreInterface<TState>(existingStore);\n  }\n\n  // Create new store\n  const newStore = createPersistedStore<TState>(\n    initialState,\n    storageKey,\n    enablePersistence,\n    selectForPersistence,\n    storage\n  );\n\n  // Register the store for future access\n  storeRegistry.set(storageKey, newStore as BoundStore<unknown>);\n\n  return createStoreInterface<TState>(newStore);\n};\n\n/**\n * Access an existing persisted state store from any component.\n */\nexport const useExistingPersistedState = <TState = unknown>(\n  storageKey: string\n): PersistedStateResult<TState> => {\n  const store = storeRegistry.get(storageKey) as\n    | BoundStore<PersistedStore<TState>>\n    | undefined;\n\n  if (!store) {\n    throw new Error(\n      `useExistingPersistedState: No store found with key \"${storageKey}\". ` +\n        `Make sure to create it first using usePersistedState.`\n    );\n  }\n\n  return createStoreInterface<TState>(store);\n};\n\n/**\n * Check if a persisted state store exists for the given key.\n */\nexport const hasPersistedState = (storageKey: string): boolean => {\n  return storeRegistry.has(storageKey);\n};\n\n/**\n * Remove a persisted state store and clear its data from storage.\n */\nexport const removePersistedState = (storageKey: string): boolean => {\n  const wasRemoved = storeRegistry.delete(storageKey);\n\n  if (wasRemoved && typeof window !== \"undefined\") {\n    try {\n      window.localStorage.removeItem(storageKey);\n    } catch (error) {\n      console.warn(\n        `Failed to remove persisted data for key \"${storageKey}\":`,\n        error\n      );\n    }\n  }\n\n  return wasRemoved;\n};\n\n/**\n * Get a list of all registered store keys.\n */\nexport const getPersistedStateKeys = (): string[] => {\n  return Array.from(storeRegistry.keys());\n};\n\n/**\n * Clear all persisted state stores and their storage data.\n */\nexport const clearAllPersistedState = (): void => {\n  const keys = getPersistedStateKeys();\n\n  // Clear from registry\n  storeRegistry.clear();\n\n  // Clear from localStorage\n  if (typeof window !== \"undefined\") {\n    keys.forEach((key) => {\n      try {\n        window.localStorage.removeItem(key);\n      } catch (error) {\n        console.warn(`Failed to clear persisted data for key \"${key}\":`, error);\n      }\n    });\n  }\n};\n\n// ------- Internal Implementation Details -------\n\n/**\n * Creates a new Zustand store with optional persistence\n */\nfunction createPersistedStore<TState>(\n  initialState: TState,\n  storageKey: string,\n  enablePersistence: boolean,\n  selectForPersistence?: (state: TState) => Partial<TState>,\n  storage?: Storage\n): BoundStore<PersistedStore<TState>> {\n  const storeCreator: StateCreator<\n    PersistedStore<TState>,\n    [],\n    [],\n    PersistedStore<TState>\n  > = (set, get) => ({\n    userState: initialState,\n    isHydrated: false,\n\n    setUserState: (newState) => {\n      set((current) => ({\n        userState:\n          typeof newState === \"function\"\n            ? (newState as (prev: TState) => TState)(current.userState)\n            : newState,\n      }));\n    },\n\n    resetToInitial: () => {\n      set({\n        userState: initialState,\n        isHydrated: get().isHydrated,\n      });\n    },\n\n    markAsHydrated: (hydrated) => {\n      set({ isHydrated: hydrated });\n    },\n  });\n\n  if (enablePersistence && storage) {\n    // Persisted store\n    return create<PersistedStore<TState>>()(\n      persist(storeCreator, {\n        name: storageKey,\n        storage: createJSONStorage(() => storage),\n        partialize: selectForPersistence\n          ? (state) => ({ userState: selectForPersistence(state.userState) })\n          : (state) => ({ userState: state.userState }),\n        onRehydrateStorage: () => (state) => {\n          state?.markAsHydrated(true);\n        },\n      })\n    );\n  } else {\n    // Non-persisted store\n    const store = create<PersistedStore<TState>>()(storeCreator);\n    store.getState().markAsHydrated(true);\n    return store;\n  }\n}\n\n/**\n * Creates the public interface that consumers interact with\n */\nfunction createStoreInterface<TState>(\n  store: BoundStore<PersistedStore<TState>>\n): PersistedStateResult<TState> {\n  return {\n    state: store((state) => state.userState),\n    setState: store((state) => state.setUserState),\n    resetState: store((state) => state.resetToInitial),\n    isHydrated: store((state) => state.isHydrated),\n  };\n}\n",
      "type": "registry:hook",
      "target": "hooks/aevr/use-persisted-state.ts"
    }
  ]
}